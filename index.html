<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>AsyncBridge by tejacques</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>AsyncBridge</h1>
          <h2>A library to help bridge C# async method execution from synchronous methods, such as in Windows Forms and ASP.NET.</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/tejacques/AsyncBridge/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/tejacques/AsyncBridge/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/tejacques/AsyncBridge" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a name="asyncbridge" class="anchor" href="#asyncbridge"><span class="octicon octicon-link"></span></a>AsyncBridge</h1>

<h2>
<a name="what-is-it" class="anchor" href="#what-is-it"><span class="octicon octicon-link"></span></a>What is it?</h2>

<p>A library to help bridge C# async method execution from synchronous methods, such as in Windows Forms and ASP.NET.</p>

<h2>
<a name="why-was-it-made" class="anchor" href="#why-was-it-made"><span class="octicon octicon-link"></span></a>Why was it made?</h2>

<p>C# 5.0 introduced async and await for concurrent task execution. This is an incredible feature that allows programmers to take advantage of asynchronous blocking to execute code more efficiently. However, there is a problem. await only works from within async functions, and outside of async functions, there is no guarantee that waiting on a task to finish won't result in a deadlock, unless you are executing a console application. From windows forms or ASP.NET contexts, the following example will result in a deadlock that will never return.</p>

<h4>
<a name="deadlock-example" class="anchor" href="#deadlock-example"><span class="octicon octicon-link"></span></a>Deadlock Example</h4>

<p>From inside a Windows Forms or ASP.NET application, the following code will cause a deadlock.</p>

<div class="highlight"><pre><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">AsyncString</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="k">return</span> <span class="s">"TestAsync"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>

    <span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="n">AsyncString</span><span class="p">();</span>
    <span class="n">task</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>

    <span class="c1">// This line will never be reached</span>
    <span class="kt">string</span> <span class="n">res</span> <span class="p">=</span> <span class="n">task</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>The reason this deadlock occurs is because the await on Task.Delay(1000) yields execution back to the calling context, which then tries to synchronously block waiting for the task to finish, but the task is never re-entered because only one thread can run a synchronization context as a time.</p>

<p>AsyncBridge resolves this problem by creating a new SynchronizationContext to run the tasks on, and awaiting on each event in a loop until execution of all tasks completes.</p>

<h2>
<a name="example-usage" class="anchor" href="#example-usage"><span class="octicon octicon-link"></span></a>Example Usage</h2>

<p>Create an AsyncBridge by calling the static <code>AsyncHelper.Wait</code> static accessor within a using directive. From there, call the <code>AsyncBridge.Run(Task&lt;T&gt; task, Action&lt;Task&lt;T&gt;&gt; callback)</code> function, which optionally takes a callback after the task has completed. This can be used to extract method results into the synchronous method. Any return values you want to extract through callbacks should first have a value initialized before the using statement.</p>

<p>A typical usage example is shown below:</p>

<div class="highlight"><pre><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">AsyncString</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="k">return</span> <span class="s">"TestAsync"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">string1</span> <span class="p">=</span> <span class="s">""</span><span class="p">;</span>
    <span class="kt">string</span> <span class="n">string2</span> <span class="p">=</span> <span class="s">""</span><span class="p">;</span>

    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">A</span> <span class="p">=</span> <span class="n">AsyncHelper</span><span class="p">.</span><span class="n">Wait</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">A</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="n">AsyncString</span><span class="p">(),</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">string1</span> <span class="p">=</span> <span class="n">x</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
        <span class="n">A</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="n">AsyncString</span><span class="p">(),</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">string2</span> <span class="p">=</span> <span class="n">x</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Total Execution time at this point will be ~1000ms, not ~2000ms</span>
    <span class="c1">// The value of string1 = "TestAsync"</span>
    <span class="c1">// The value of string2 = "TestAsync"</span>
<span class="p">}</span>
</pre></div>

<p>All async functions called by AsyncBridge.Run(Task) inside of the using scope will be executed asynchronously. The async tasks are waited on in a nondeadlocking manner in the destructor of AsyncBridge.</p>

<h2>
<a name="exception-handling" class="anchor" href="#exception-handling"><span class="octicon octicon-link"></span></a>Exception Handling</h2>

<p>One of the most annoying problems in an async context can be dealing with exceptions. AsyncBridge bubbles up exceptions that occur and stops execution. An example of error handling can be seen below:</p>

<div class="highlight"><pre><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">AsyncStringException</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Test Exception."</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="s">""</span><span class="p">;</span>

    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">A</span> <span class="p">=</span> <span class="n">AsyncHelper</span><span class="p">.</span><span class="n">Wait</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">A</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="n">AsyncStringException</span><span class="p">(),</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">s</span> <span class="p">=</span> <span class="n">x</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// e.Message                 = "AsyncBridge.Run method threw an exception."</span>
        <span class="c1">// e.InnerException.Message) = "Test Exception."</span>
        <span class="c1">// Handle exception</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2>
<a name="fire-and-forget" class="anchor" href="#fire-and-forget"><span class="octicon octicon-link"></span></a>Fire and Forget</h2>

<p>The "Fire and Forget" pattern is an excellent way to keep the UI or ASP.NET request thread responsive by executing longer running tasks in the background. A good example is database logging for non user-facing data (I.E. The user doesn't need to know that a database action succeeded). This pattern can be accomplished in a variety of different ways, however in Windows Forms or ASP.NET context, most of them don't work, or have serious flaws.</p>

<p>The two natural seeming choices are executing an <code>async void</code> method, or an <code>async Task</code> method without waiting for it to complete.</p>

<p>Async void methods at first appear to do exactly what is wanted -- asynchronously run a task without any regard for it's result. However, ASP.NET threads will finish everything in a synchronization context before returning, so pages will not serve until any <code>async void</code> methods called have completed, which is the complete opposite of fire and forget -- fire and wait. Calling an async Task method and not waiting on the result has the same behavior.</p>

<p>In order to actually get the desired behavior, one needs to run the fire and forget method in a new thread. The Task thread pool works well for this meaning Task.Run is a good choice. The caveat of Task.Run is that any exceptions that occur unhandled will sit around occupying memory until they are dealt with. Since Fire and forget method exceptions usually aren't at the top level, memory leaks can occur. In order to resolve this, you need to wrap try/catch around the awaited task which Task.Run will execute. Care must be taken to actually await the task, because otherwise the exception will remain uncaught as the try/catch will be wrapping the start of the task rather than the task in its entirety. This is what the AsyncHelper.FireAndForget function does.</p>

<h4>
<a name="fire-and-forget-example" class="anchor" href="#fire-and-forget-example"><span class="octicon octicon-link"></span></a>Fire and Forget Example</h4>

<div class="highlight"><pre><span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">FAFExample</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Test exception"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">AsyncHelper</span><span class="p">.</span><span class="n">FireAndForget</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">FAFExample</span><span class="p">());</span> <span class="c1">// Will silently ignore exceptions</span>
    <span class="n">AsyncHelper</span><span class="p">.</span><span class="n">FireAndForget</span><span class="p">(</span>                     <span class="c1">// Will handle exceptions by writing</span>
        <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">FAFExample</span><span class="p">(),</span>                        <span class="c1">// e.Message to the console</span>
        <span class="n">e</span> <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Message</span><span class="p">));</span>        <span class="c1">// e.Message = "Test exception"</span>

    <span class="c1">// These lines will be reached immediately, not</span>
    <span class="c1">// ~1000ms or ~2000ms from the previous lines)</span>
    <span class="c1">// and method execution will not block.</span>
<span class="p">}</span>
</pre></div>

<p>This can be used in any context, from async methods or synchronous methods, and from inside or outside of <code>using(AsyncBridge)</code> blocks</p>

<h2>
<a name="inspiration" class="anchor" href="#inspiration"><span class="octicon octicon-link"></span></a>Inspiration</h2>

<p>This project was inspired by:</p>

<ul>
<li><a href="http://social.msdn.microsoft.com/Forums/en-US/163ef755-ff7b-4ea5-b226-bbe8ef5f4796/is-there-a-pattern-for-calling-an-async-method-synchronously">AsyncInline</a></li>
<li><a href="https://github.com/okws/sfslite/wiki/tame">Tame</a></li>
<li><a href="https://github.com/Sidnicious/team">Team</a></li>
</ul>
        </section>

        <footer>
          AsyncBridge is maintained by <a href="https://github.com/tejacques">tejacques</a><br>
        </footer>

        
      </div>
    </div>
  </body>
</html>
