{"name":"AsyncBridge","tagline":"A library to help bridge C# async method execution from synchronous methods, such as in Windows Forms and ASP.NET.","body":"AsyncBridge\r\n===========\r\n\r\nWhat is it?\r\n-----------\r\n\r\nA library to help bridge C# async method execution from synchronous methods, such as in Windows Forms and ASP.NET.\r\n\r\nWhy was it made?\r\n----------------\r\n\r\nC# 5.0 introduced async and await for concurrent task execution. This is an incredible feature that allows programmers to take advantage of asynchronous blocking to execute code more efficiently. However, there is a problem. await only works from within async functions, and outside of async functions, there is no guarantee that waiting on a task to finish won't result in a deadlock, unless you are executing a console application. From windows forms or ASP.NET contexts, the following example will result in a deadlock that will never return.\r\n\r\n#### Deadlock Example\r\n\r\nFrom inside a Windows Forms or ASP.NET application, the following code will cause a deadlock.\r\n\r\n```csharp\r\npublic async Task<string> AsyncString()\r\n{\r\n    await Task.Delay(1000);\r\n    return \"TestAsync\";\r\n}\r\n\r\npublic void Test()\r\n{\r\n    \r\n    var task = AsyncString();\r\n    task.Wait();\r\n    \r\n    // This line will never be reached\r\n    string res = task.Result;\r\n}\r\n```\r\n\r\nThe reason this deadlock occurs is because the await on Task.Delay(1000) yields execution back to the calling context, which then tries to synchronously block waiting for the task to finish, but the task is never re-entered because only one thread can run a synchronization context as a time.\r\n\r\nAsyncBridge resolves this problem by creating a new SynchronizationContext to run the tasks on, and awaiting on each event in a loop until execution of all tasks completes.\r\n\r\nExample Usage\r\n-------------\r\n\r\nCreate an AsyncBridge by calling the static `AsyncHelper.Wait` static accessor within a using directive. From there, call the `AsyncBridge.Run(Task<T> task, Action<Task<T>> callback)` function, which optionally takes a callback after the task has completed. This can be used to extract method results into the synchronous method. Any return values you want to extract through callbacks should first have a value initialized before the using statement.\r\n\r\nA typical usage example is shown below:\r\n```csharp\r\npublic async Task<string> AsyncString()\r\n{\r\n    await Task.Delay(1000);\r\n    return \"TestAsync\";\r\n}\r\n\r\npublic void Test()\r\n{\r\n    string string1 = \"\";\r\n    string string2 = \"\";\r\n\r\n    using (var A = AsyncHelper.Wait)\r\n    {\r\n        A.Run(AsyncString(), x => string1 = x.Result);\r\n        A.Run(AsyncString(), x => string2 = x.Result);\r\n    }\r\n    \r\n    // Total Execution time at this point will be ~1000ms, not ~2000ms\r\n    // The value of string1 = \"TestAsync\"\r\n    // The value of string2 = \"TestAsync\"\r\n}\r\n```\r\n\r\nAll async functions called by AsyncBridge.Run(Task) inside of the using scope will be executed asynchronously. The async tasks are waited on in a nondeadlocking manner in the destructor of AsyncBridge.\r\n\r\nException Handling\r\n------------------\r\n\r\nOne of the most annoying problems in an async context can be dealing with exceptions. AsyncBridge bubbles up exceptions that occur and stops execution. An example of error handling can be seen below:\r\n```csharp\r\npublic async Task<string> AsyncStringException()\r\n{\r\n    await Task.Delay(1000);\r\n    throw new Exception(\"Test Exception.\");\r\n}\r\n\r\npublic void Test()\r\n{\r\n    string s = \"\";\r\n\r\n    try\r\n    {\r\n        using (var A = AsyncHelper.Wait)\r\n        {\r\n            A.Run(AsyncString(), x => s = x.Result);\r\n        }\r\n    }\r\n    catch (Exception e)\r\n    {\r\n        // e.Message                 = \"AsyncBridge.Run method threw an exception.\"\r\n        // e.InnerException.Message) = \"Test Exception.\"\r\n        // Handle exception\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n\r\nFire and Forget\r\n---------------\r\n\r\nThe \"Fire and Forget\" pattern is an excellent way to keep the UI or ASP.NET request thread responsive by executing longer running tasks in the background. A good example is database logging for non user-facing data (I.E. The user doesn't need to know that a database action succeeded). This pattern can be accomplished in a variety of different ways, however in Windows Forms or ASP.NET context, most of them don't work, or have serious flaws.\r\n\r\nThe two natural seeming choices are executing an `async void` method, or an `async Task` method without waiting for it to complete.\r\n\r\nAsync void methods at first appear to do exactly what is wanted -- asynchronously run a task without any regard for it's result. However, ASP.NET threads will finish everything in a synchronization context before returning, so pages will not serve until any `async void` methods called have completed, which is the complete opposite of fire and forget -- fire and wait. Calling an async Task method and not waiting on the result has the same behavior.\r\n\r\nIn order to actually get the desired behavior, one needs to run the fire and forget method in a new thread. The Task thread pool works well for this meaning Task.Run is a good choice. The caveat of Task.Run is that any exceptions that occur unhandled will sit around occupying memory until they are dealt with. Since Fire and forget method exceptions usually aren't at the top level, memory leaks can occur. In order to resolve this, you need to wrap try/catch around the awaited task which Task.Run will execute. Care must be taken to actually await the task, because otherwise the exception will remain uncaught as the try/catch will be wrapping the start of the task rather than the task in its entirety. This is what the AsyncHelper.FireAndForget function does.\r\n\r\n#### Fire and Forget Example\r\n\r\n```csharp\r\nprivate async Task FAFExample()\r\n{\r\n    await Task.Delay(1000);\r\n    throw new Exception(\"Test exception\");\r\n}\r\n\r\npublic void Test()\r\n{\r\n    AsyncHelper.FireAndForget(() => FAFExample()); // Will silently ignore exceptions\r\n    AsyncHelper.FireAndForget(                     // Will handle exceptions by writing\r\n        () => FAFExample(),                        // e.Message to the console\r\n        e => Console.WriteLine(e.Message));        // e.Message = \"Test exception\"\r\n        \r\n    // These lines will be reached immediately, not\r\n    // ~1000ms or ~2000ms from the previous lines)\r\n    // and method execution will not block.\r\n}\r\n```\r\n\r\nThis can be used in any context, from async methods or synchronous methods, and from inside or outside of `using(AsyncBridge)` blocks\r\n\r\nInspiration\r\n-----------\r\n\r\nThis project was inspired by:\r\n\r\n- [AsyncInline](http://social.msdn.microsoft.com/Forums/en-US/163ef755-ff7b-4ea5-b226-bbe8ef5f4796/is-there-a-pattern-for-calling-an-async-method-synchronously)\r\n- [Tame](https://github.com/okws/sfslite/wiki/tame)\r\n- [Team](https://github.com/Sidnicious/team)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}